\section{Аналитическая часть} \label{analysis}

В данном разделе будут рассмотрены принципы работы с гипертекстовыми документами согласно объектной модели документа и виртуальной объектной модели документа.

\subsection{Гипертекстовые документы}

Гипертекстовым~\cite{hypertext} документом является документ, состоящий из текстовых страниц, имеющих перекрёстные ссылки. 
В данной работе под гипертекстовыми документами будут подразумеваться документы, написанные при помощи языка гипертекстовой разметки (англ. \textit{HyperText Markup Language} --- HTML)~\cite{html}, а именно документы, соблюдающие стандарт HTML5~\cite{html-doc}.


Данный выбор обусловлен тем, что использование HTML5 получило широкое распространение в Всемирной сети~\cite{internet} благодаря рекомендации~\cite{html-recommendation} к использованию от Консорциума Всемирной паутины (англ. \textit{World Wide Web \newline Consortium} --- W3C)~\cite{w3c}.
Вследствие данной рекомендации HTML документы поддерживают большинство самых распространённых браузеров в России, такие, как Google Chrome, Яндекс.Браузер и Safari~\cite{browser-popularity-russia}. 

\subsection{Объектная модель документа}

Объектная модель документа (англ. \textit{Document Object Model} --- DOM)~\cite{dom} --- программный интерфейс для HTML, XML и CSV документов. 
Он обеспечивает структурированное представление документа (дерева~\cite{balanced-tree}), и определяет способ, по которому структура может быть доступна для программы, для изменения структуры документа, его стиля и содержания.
Представление DOM состоит из структурированной группы узлов и объектов, которые имеют свойства и методы.

Стадарт W3C DOM~\cite{dom-doc} формирует основы DOM, реализованные в большинстве современных браузеров. 
Для описания структуры DOM потребуются следующие термины: корневой, родительские и дочерние элементы. 
Корневой элемент находится в основании всей структуры и не имеет родительского элемента.
Дочерние элементы не просто находятся внутри родительских, но и наследуют различные свойства от них.
Рассмотрим, как выглядит DOM-представление HTML документа, представленного на листинге \ref{code:simple}. 

\begin{code}
	\captionsetup{justification=raggedright,singlelinecheck=off,margin=4mm}
	\captionof{listing}{Пример простого HTML документа}
	\label{code:simple}
	\inputminted
	[
	frame=single,
	framerule=0.5pt,
	framesep=20pt,
	fontsize=\small,
	tabsize=4,
	linenos,
	numbersep=5pt,
	xleftmargin=10pt,
	]
	{text}
	{code/simple.html}
\end{code}

Корневым элементом здесь является \codeword{html}, он не имеет родительского элемента и имеет два дочерних --- \codeword{head} и \codeword{body}. По отношению друг к другу элементы \codeword{head} и \codeword{body} являются сиблингами (братьями и сестрами). В каждый из них можно вложить еще много дочерних элементов. Например, в \codeword{head} обычно находятся \codeword{link}, \codeword{meta}, \codeword{script} или \codeword{title}.

Данный HTML документ будет иметь следующее DOM-представление, изображённое на рисунке \ref{fig:simple-dom-1}.

\begin{figure}[h]
	\centering
	\captionsetup{justification=centering}
	\includegraphics[width=130mm]{img/simple-dom-1.png}
	\caption{Пример DOM-представления для простого HTML документа}
	\label{fig:simple-dom-1}
\end{figure}

Все эти теги не являются уникальными, и в одном документе может быть по несколько экземпляров каждого из них.

В \codeword{body} могут находиться разнообразные элементы. 
Например, в родительском \codeword{body} --- дочерний элемент \codeword{header}, в элементе \codeword{header} --- дочерний элемент \codeword{section}, в родительском \codeword{section} --- дочерний \codeword{div}, в \codeword{div} --- элемент \codeword{h3}, и, наконец, в \codeword{h3} — элемент \codeword{span}. 
В этом случае \codeword{span} не имеет дочерних элементов, но их можно добавить в любой момент.
Пример того, как можно описать добавление данных элементов, представлен на рисунке \ref{fig:simple-dom-2}.

\begin{figure}[h]
	\centering
	\captionsetup{justification=centering}
	\includegraphics[width=120mm]{img/simple-dom-2.png}
	\caption{Пример DOM-представления для чуть более сложного HTML документа}
	\label{fig:simple-dom-2}
\end{figure}

Пример, при котором система была бы более разветвлённая и с большим количеством вложений, представлен на рисунке \ref{fig:complicated-dom}.

\begin{figure}[h]
	\centering
	\includegraphics[width=170mm]{img/complicated-dom.png}
	\caption{Пример DOM-представления для сложного HTML документа}
	\label{fig:complicated-dom}
\end{figure}

На схеме изображено довольно большое DOM-дерево, и его сложно воспринимать из-за его размера.
Для удобства часто используется система многоуровневых списков. 
Пример того, как предыдущее дерево можно преобразовать в такой список, представлен на рисунке \ref{fig:complicated-dom-list}.

\begin{figure}[h]
	\centering
	\captionsetup{justification=centering}
	\includegraphics[width=115mm]{img/complicated-dom-list.png}
	\caption{Пример DOM-представления для сложного HTML документа в виде списка}
	\label{fig:complicated-dom-list}
\end{figure}

\clearpage

Элементы могут наследовать не все, но многие свойства своих родителей --- например, цвет, шрифт, видимость, размеры и~т.~д.

Таким образом, чтобы задать стиль шрифта на всей странице, потребуется не прописывать цвет для каждого элемента, а задать его только для \codeword{body}. 
А чтобы изменить наследуемое свойство у дочернего элемента, нужно прописать только ему новые свойства. 
Наследование удобно для создания единообразной страницы.
DOM-узлы содержат гораздо больше информации, чем просто данные о дочерних узлах \cite{dom-element}.
Они также содержат информацию о родительском узле, стилях, обработчиках событий и свойствах элемента, его исходном  коде и~т.~д.
В таких браузерах, как Google Chrome, DOM-дерево страницы можно посмотреть, например, при помощи инструментов разработчика \cite{devtools}.

\subsubsection{Алгоритм построения документа с использованием  DOM}


Рассмотрим алгоритм построения DOM-дерева по имеющемуся HTML документу.

Для того, чтобы построить дерево объектной модели, требуется обработать документ и произвести операцию вставки в получающееся дерево $n$ раз, где $n$ - количество элементов.

\subsubsection{Алгоритм обновления документа с использованием DOM}

Обновление структуры DOM --- распространённая и часто используемая операция, производимая, например, в случае, когда документ должен меняться в ответ на действия пользователя (любая активность на странице).

Рекоммендация W3C в таком случае призывает повторно отрисовать обновлённое дерево с нуля --- то есть, каждый раз, когда необходимо обновить дерево, будет использоваться алгоритм отображения.

\subsubsection{Алгоритм отображения документа с использованием DOM}

Полученное DOM-дерево необходимо отобразить, чтобы пользователь получил возможность увидеть результаты отображения у себя на экране.

Чтобы это сделать, придётся сделать полный обход DOM-дерева и отобразить каждый из имеющихся элементов.

\subsection{Виртуальная объектная модель документа}

Основной проблемой DOM является то, что он никогда не был приспособлен для динамического интерфейса~\cite{not-dynamic}. 
Он предоставляет удобный программный интерфейс, позволяющий взаимодействовать с ним из кода, но это не решает проблем с производительностью.
Современные социальные сети, такие, как ВКонтакте, Twitter или Facebook будут использовать тысячи DOM узлов, взаимодействие с которыми может занимать ощутимое для пользователя время, в то время как создатели браузера Google Chrome, к примеру, рекомендуют~\cite{dom-max} не использовать в одной странице более 800 узлов.

Одним из решений данной проблемы служит технология виртуальной объектной модели, которая, хоть  и не является стандартом, позволяет по-прежнему взаимодействовать с DOM, но делать это как можно реже.

Виртуальная объектная модель документа (англ. \textit{Virtual Document Object Model} --- VDOM)~\cite{vdom} ---  концепт программирования, в которой идеальное (<<виртуальное>>) представление пользовательского интерфейса хранится в памяти и синхронизуется с <<настоящим>> DOM при помощи алгоритмов согласования.

Вместо того, чтобы работать с DOM напрямую, согласно концепции\break VDOM работа происходит с его легковесной копией, хранящийся непосредственно в памяти компьютера. 
За счёт этого операции вставки, сравнения, удаления и обхода узлов дерева происходит быстрее благодаря отсутствию необходимости отрисовывать изменения после каждой операции.

Когда в пользовательский интерфейс добавляются новые элементы, создаётся виртуальная модель DOM, представленная в виде дерева. 
Если состояние любого из элементов изменяется, создаётся новое виртуальное дерево DOM. 
Затем это дерево сравнивается с предыдущим виртуальным деревом.


Рассмотрим, как для простого  HTML документа, представленного на листинге \ref{code:dom-to-vdom-html} осуществляется представление DOM- (рисунок \ref{fig:dom-to-vdom-dom}) и VDOM- дерева (рисунок \ref{code:dom-to-vdom-vdom}).

\begin{code}
	\captionsetup{justification=raggedright,singlelinecheck=off,margin=4mm}
	\captionof{listing}{Простой HTML документ}
	\label{code:dom-to-vdom-html}
	\inputminted
	[
	frame=single,
	framerule=0.5pt,
	framesep=20pt,
	fontsize=\small,
	tabsize=4,
	linenos,
	numbersep=5pt,
	xleftmargin=10pt,
	]
	{text}
	{code/dom-to-vdom.html}
\end{code}
 
\begin{figure}[h]
	\centering
	\includegraphics[width=70mm]{img/dom-to-vdom-dom.png}
	\caption{DOM-дерево для простого HTML документа}
	\label{fig:dom-to-vdom-dom}
\end{figure}

\begin{code}
	\captionsetup{justification=raggedright,singlelinecheck=off,margin=4mm}
	\captionof{listing}{VDOM-дерево для простого HTML документа}
	\label{code:dom-to-vdom-vdom}
	\inputminted
	[
	frame=single,
	framerule=0.5pt,
	framesep=20pt,
	fontsize=\small,
	tabsize=4,
	linenos,
	numbersep=5pt,
	xleftmargin=10pt,
	]
	{text}
	{code/dom-to-vdom-vdom.js}
\end{code}

Данный пример служит лишь для демонстрации того, как может осуществляться представление VDOM. 
Реальные деревья содержат намного большее число узлов~\cite{dom-element}, а элементы DOM имеют гораздо больше полей (классы, идентификаторы, стили, обработчики событий, поля данных, типы и значения, вспомогательные поля и~т.~п.), и тем не менее содержится гораздо меньше информации, чем в узлах DOM за счёт того, что нет необходимости хранить данные, помогающие визуализировать элемент (за это отвечает DOM).

\subsubsection{Алгоритм построения документа с использованием VDOM}

Рассмотрим, как происходит построение VDOM-дерева по гипертекстовому документу.

Чтобы построить виртуальное дерево, требуется обработать документ и осуществить операцию вставки в виртуальное представление $n$ раз, где $n$ --- количество элементов. 
После этого необходимо сделать полный обход виртуального дерева и для каждого элемента создать соответствующие ему узлы DOM-дерева.

\subsubsection{Алгоритм обновления документа с использованием VDOM}

Если состояние любого из элементов необходимо изменить, создаётся новое виртуальное дерево.
Затем получившееся дерево сравнивается с предыдущим виртуальным деревом объектной модели документа и происходит вычисления наилучшего из возможных методов внесения изменений в реальной DOM. 
Это гарантирует минимальное количество операций с реальной DOM, что приводит к снижении стоимости обновления реальной модели. 

На рисунке \ref{fig:vdom-example} показано виртуальное дерево DOM и процесс сравнения.

\begin{figure}[h]
	\centering
	\captionsetup{justification=centering}
	\includegraphics[width=130mm]{img/vdom-example.png}
	\caption{Пример работы алгоритма обновления документа при помощи VDOM}
	\label{fig:vdom-example}
\end{figure}

Красными кружками обозначены узлы, которые изменились --- эти узлы представляют собой элементы пользовательского интерфейса, состояние котоых изменилось.
Затем вычисляется разница между предыдущей версией\break VDOM-дерева и текущей (посредством алгоритма согласования), после чего всё родительское поддерево повторно визуализируется для получения обновлённого пользовательского интерфейса.

\subsubsubsection{Алгоритм согласования}

Алгоритм согласования (англ. \textit{reconciliation})~\cite{reconciliation} --- эвристический алгоритм решения проблемы трансформации одного дерева в другое за минимальное число операций.
Он основан на следующих двух предположениях:

Во-первых, два элемента с разыми типами произведут разные деревья.

Во-вторых, можно указать, какие дочерние элементы могут оставаться стабильными между разными отображениями при помощи специального параметра \codeword{key}.

При сравнении двух деревьев первым делом производится сравнение родительских элементов, начиная с корневого.
Дальнейшее поведение различается в зависимости от типов родительских элементов.

Всякий раз, когда родительские элементы имеют различные типы, старое VDOM-дерево уничтожается и с нуля строится новое.
Так, переходы от \codeword{<div>} к \codeword{<a>} или от \codeword{<img>} к \codeword{<div>} приведут к полному перестроению дерева, старое DOM-дерево также уничтожается.

Любые элементы, лежащие ниже родительского, будут уничтожены, а их состояние уничтожится.
На листиге \ref{code:reconciliation-diff-types} приведён пример изменения узла, при котором меняется его тип и всё поддерево уничтожается.

\begin{code}
	\captionsetup{justification=raggedright,singlelinecheck=off,margin=4mm}
	\captionof{listing}{Пример HTML-узлов разного типа, при сравнении которых деревья будут полностью перестроены}
	\label{code:reconciliation-diff-types}
	\inputminted
	[
	frame=single,
	framerule=0.5pt,
	framesep=20pt,
	fontsize=\small,
	tabsize=4,
	linenos,
	numbersep=5pt,
	xleftmargin=10pt,
	]
	{text}
	{code/reconciliation-diff-types.html}
\end{code}

При сравнении DOM-элементов одного типа, алгоритм согласования проверяет их атрибуты, сохраняет лежащий в основе элементов DOM-узел и обновляет только изменённые атрибуты (пример таких элементов приведён на листинге \ref{code:reconciliation-same-types}).

\begin{code}
	\captionsetup{justification=raggedright,singlelinecheck=off,margin=4mm}
	\captionof{listing}{Пример HTML-узлов одного типа, при сравнении которых будет сохранена лишь разница содержимого атрибутов}
	\label{code:reconciliation-same-types}
	\inputminted
	[
	frame=single,
	framerule=0.5pt,
	framesep=20pt,
	fontsize=\small,
	tabsize=4,
	linenos,
	numbersep=5pt,
	xleftmargin=10pt,
	]
	{text}
	{code/reconciliation-same-types.html}
\end{code}

При рекурсивном обходе дочерних элементов DOM-узла алгоритм согласования проходит по спискам потомков одновременно и находит отличие.
Например, при добавлении элемента в конец дочерних элементов, преобразование между этими деревьями работает хорошо, определяя минимальный набор операций.

\begin{code}
	\captionsetup{justification=raggedright,singlelinecheck=off,margin=4mm}
	\captionof{listing}{Пример HTML-узлов при добавлении элемента в конец дочернего}
	\label{code:reconciliation-add-to-end}
	\inputminted
	[
	frame=single,
	framerule=0.5pt,
	framesep=20pt,
	fontsize=\small,
	tabsize=4,
	linenos,
	numbersep=5pt,
	xleftmargin=10pt,
	]
	{text}
	{code/reconciliation-add-to-end.html}
\end{code}

Алгоритм согласования сравнит два дерева \codeword{<li>первый</li>}, сравнит два дерева \codeword{<li>второй</li>}, а затем вставит дерево \codeword{<li>третий</li>}. 

При вставке элемента в начало, прямолинейная реализация такого алгоритма будет работать не эффективно. Например, преобразование между этими деревьями работает плохо, минимальный набор операций для преобразованя одного дерева в другое не будет найден.

Алгоритм согласования будет преобразовывать каждого потомка, вместо того, чтобы оставить элементы \codeword{<li>Санкт-Петербург</li>} и \linebreak
\codeword{<li>Москва</li> }. Пример таких узлов продемонстрирован на листинге  \ref{code:reconciliation-add-to-start}.
\newline\newline

\begin{code}
	\captionsetup{justification=raggedright,singlelinecheck=off,margin=4mm}
	\captionof{listing}{Пример HTML-узлов при добавлении элемента в начало дочернего}
	\label{code:reconciliation-add-to-start}
	\inputminted
	[
	frame=single,
	framerule=0.5pt,
	framesep=20pt,
	fontsize=\small,
	tabsize=4,
	linenos,
	numbersep=5pt,
	xleftmargin=10pt,
	]
	{text}
	{code/reconciliation-add-to-start.html}
\end{code}

Для решения этой проблемы существуют вспомогательные атрибуты \codeword{key} --- ключи~\cite{keys}. Когда у дочерних элементов есть ключи, алгоритм согласования использует их, чтобы сопоставить потомков исходного виртуального дерева с потомками полученного виртуального дерева.

Значение атрибута \codeword{key} при этом должно быть уникальным.
Так, как значение ключа  можно использовать уникальный идентификатор элемента, если он есть, или же можно добавить новое свойство идентификатора или прохешировать данные, чтобы сгенерировать ключ. 
Достаточно, чтобы ключ элемента был уникальным среди его соседей, а не глобально.

Например, если добавить \codeword{key} к примеру выше, преобразование дерева будет верным.
\newline

\begin{code}
	\captionsetup{justification=raggedright,singlelinecheck=off,margin=4mm}
	\captionof{listing}{Пример HTML-узлов при добавлении элемента в начало дочернего с использованием ключей}
	\label{code:reconciliation-add-to-start-keys}
	\inputminted
	[
	frame=single,
	framerule=0.5pt,
	framesep=20pt,
	fontsize=\small,
	tabsize=4,
	linenos,
	numbersep=5pt,
	xleftmargin=10pt,
	]
	{text}
	{code/reconciliation-add-to-start-keys.html}
\end{code}

Алгоритм согласования является эвристическим~\cite{euristic} алгоритмом, и если предположения, на которых он основан, не соблюдены, пострадает производительность.

Так, алгоритм не будет пытаться сопоставить поддеревья элементов разных типов, а ключи должны быть стабильными (например, ключ, произведённый случайно, не является стабильным), предсказуемым и уникальным.
Нестабильные ключи вызовут необязательное пересоздание многих экземпляров элемента и DOM-узлов, что может вызывать ухудшение производительности и потерю состояния у дочерних элементов.
\clearpage

\subsubsection{Алгоритм отображения документа с использованием VDOM}

Отображение гипертекстового документа с использованием VDOM происходит аналогично алгоритму отображения с использованием DOM, за исключением того, что DOM-дерево получается благодаря VDOM-дереву.

\subsection{Сравнение DOM и VDOM}

Проведём сравнение объектной модели документа и виртуальной объектной модели документа по следующим критериям: 
\begin{enumerate}[label=\arabic*)]
	\item память --- количество используемой памяти относительно друг друга;
	\item поведение --- действия моделей при обновлении элемента;
	\item доступ к HTML --- может ли изменять HTML напрямую;
	\item смысл --- что представляет модель.
\end{enumerate}

\begin{table}[h]
	\begin{center}
		\captionsetup{justification=raggedright,singlelinecheck=off,margin=3mm}
		\caption{Сравнительная таблица DOM и VDOM}
		\begin{tabular}{| c | c |c |}
			\hline
			Критерий & DOM & VDOM \\
			\hline
			Память & Больше, чем у VDOM & Меньше, чем у DOM \\
			\hline
			Поведение & Обновение DOM-дерева & Обновление изменяемого элемента\\
			\hline
			\begin{tabular}{c}
				Доступ \\
				к HTML
			\end{tabular} & \begin{tabular}{c}
				Может менять \\
				HTML напрямую
			\end{tabular} &  \begin{tabular}{c}
			Не может менять \\
			HTML напрямую
		\end{tabular}\\
			\hline
			Смысл &  \begin{tabular}{c}
				Представляет собой\\
				UI документа
			\end{tabular}& \begin{tabular}{c}
			Является виртуальным \\
			представлением DOM
		\end{tabular} \\
			\hline
		\end{tabular}
		\label{table:comparison}
	\end{center}
\end{table}

\subsection*{Вывод}

В данном разделе были рассмотрены принципы работы с гипертекстовыми документами согласно объектной модели документа (DOM) и витруальной объектной модели документа (VDOM) и проведено их сравнение.
Также был рассмотрен алгоритм согласования, находящий минимальный набор операций, необходимых для преобразования одного дерева в другое.
В соответствии с поставленной целью, необходимо разработать алгоритмы обновления документа с использованием DOM и VDOM, а также алгоритма согласования.

На вход алгоритма обновления с использованием DOM будут подаваться обрабатываемый элемент, изменяемый элемент и элемент, который нужно отрисовать вместо него. 
На вход алгоритма обновления документа с использованием VDOM будут подаваться корни старого VDOM-дерева и нового VDOM-дерева, а на вход алгоритма согласования - обрабатываемые узлы старого и нового VDOM-деревьев, а также указатели на массивы изменений узлов и поддеревьев,